msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-06 18:04+0800\n"
"PO-Revision-Date: 2024-01-14 12:29+0000\n"
"Last-Translator: Russell Keith-Magee <russell@keith-magee.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/"
"beeware/tutorial/tutorial-7/zh_Hans/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 5.4-dev\n"
"Generated-By: Babel 2.14.0\n"

#: ../../tutorial/tutorial-7.rst:3 8ad7bf512a0341b6aeb95e5d97c7c838
#, fuzzy
msgid "Tutorial 7 - Get this (third)-party started"
msgstr "教程 7 - 启动这个（第三）派对"

#: ../../tutorial/tutorial-7.rst:5 dccb6e45fcb546afae3b5c0ec3814092
#, fuzzy
msgid "So far, the app we've built has only used our own code, plus the code provided by BeeWare. However, in a real-world app, you'll likely want to use a third-party library, downloaded from the Python Package Index (PyPI)."
msgstr "到目前为止，我们构建的应用程序只使用了我们自己的代码和 BeeWare 提供的代码。不过，在实际应用中，您很可能需要使用从 Python 软件包索引（PyPI）下载的第三方库。"

#: ../../tutorial/tutorial-7.rst:9 9c72680e426c4971ad48c69a5f1b6fd8
#, fuzzy
msgid "Let's modify our app to include a third-party library."
msgstr "让我们修改应用程序，加入第三方库。"

#: ../../tutorial/tutorial-7.rst:12 aee775bc57e0476cb41dd06723ebc78d
#, fuzzy
msgid "Accessing an API"
msgstr "访问应用程序接口"

#: ../../tutorial/tutorial-7.rst:14 02b45d1c8d304308929f8c26ac51cd22
#, fuzzy
msgid "A common task an app will need to perform is to make a request on a web API to retrieve data, and display that data to the user. This is a toy app, so we don't have a *real* API to work with, so we'll use the `{JSON} Placeholder API <https://jsonplaceholder.typicode.com>`__ as a source of data."
msgstr "应用程序需要执行的一项常见任务是向网络应用程序接口发出请求以获取数据，并将数据显示给用户。这是一个玩具应用程序，因此我们没有*真正*的 API 可供使用，所以我们将使用 `{JSON} 占位符 API <https://jsonplaceholder.typicode.com>`__ 作为数据源。"

#: ../../tutorial/tutorial-7.rst:19 daea622b5596467f911c43d70e1c255c
#, fuzzy
msgid "The {JSON} Placeholder API has a number of \"fake\" API endpoints you can use as test data. One of those APIs is the ``/posts/`` endpoint, which returns fake blog posts. If you open ``https://jsonplaceholder.typicode.com/posts/42`` in your browser, you'll get a JSON payload describing a single post - some `Lorum ipsum <https://en.wikipedia.org/wiki/Lorem_ipsum>`__ content for a blog post with ID 42."
msgstr "{JSON} 占位符 API 有许多 \"伪造 \"的 API 端点，您可以将其用作测试数据。其中一个 API 是 ``/posts/`` 端点，它会返回虚假的博客文章。如果在浏览器中打开 ``https://jsonplaceholder.typicode.com/posts/42`` ，就会得到一个描述单篇博文的 JSON 有效载荷--ID 为 42 的博文的一些 `Lorum ipsum <https://en.wikipedia.org/wiki/Lorem_ipsum>`__ 内容。"

#: ../../tutorial/tutorial-7.rst:26 c2c679657f134405b867a2a59eaa858f
#, fuzzy
msgid "The Python standard library contains all the tools you'd need to access an API. However, the built-in APIs are very low level. They are good implementations of the HTTP protocol - but they require the user to manage lots of low-level details, like URL redirection, sessions, authentication, and payload encoding. As a \"normal browser user\" you're probably used to taking these details for granted, as a browser manages these details for you."
msgstr "Python 标准库包含访问 API 所需的所有工具。然而，内置的 API 是非常低级的。它们很好地实现了 HTTP 协议，但需要用户管理大量低级细节，如 URL 重定向、会话、身份验证和有效负载编码。作为一名 \"普通浏览器用户\"，你可能已经习惯了将这些细节视为理所当然，因为浏览器会为你管理这些细节。"

#: ../../tutorial/tutorial-7.rst:33 af3ad600eb7e4669a5b7c6f4d78aa619
#, fuzzy
msgid "As a result, people have developed third-party libraries that wrap the built-in APIs and provide a simpler API that is a closer match for the everyday browser experience. We're going to use one of those libraries to access the {JSON} Placeholder API - a library called `httpx <https://www.python-httpx.org>`__."
msgstr "因此，人们开发了第三方库来封装内置的 API，并提供更简单的 API，使其更符合日常的浏览器体验。我们将使用其中一个库来访问 {JSON} 占位符 API - 一个名为 `httpx <https://www.python-httpx.org>`__ 的库。"

#: ../../tutorial/tutorial-7.rst:38 f1e8759bfb5f4a1088d9fd1280370626
#, fuzzy
msgid "Let's add a ``httpx`` API call to our app. Add an import to the top of the ``app.py`` to import ``httpx``::"
msgstr "让我们在应用程序中添加一个 ``httpx`` API 调用。在 ``app.py`` 顶部添加导入，以导入 ``httpx``:："

#: ../../tutorial/tutorial-7.rst:43 c697793e25ab4f09855b3b7dee7a04c8
#, fuzzy
msgid "Then modify the ``say_hello()`` callback so it looks like this::"
msgstr "然后修改 ``say_hello()`` 回调，使其看起来像这样：："

#: ../../tutorial/tutorial-7.rst:56 63fffe4e06de4459b53d2afeefcd7e5f
msgid "This will change the ``say_hello()`` callback so that when it is invoked, it will:"
msgstr "这将更改 ``say_hello()`` 回调，使它在被调用时，会:"

#: ../../tutorial/tutorial-7.rst:59 83ef2db9c558441e975326257fed14ef
#, fuzzy
msgid "make a GET request on the JSON placeholder API to obtain post 42;"
msgstr "在 JSON 占位符 API 上发出 GET 请求，以获取帖子 42；"

#: ../../tutorial/tutorial-7.rst:61 7870ca0e9bce444d9bf1137ee7edfbee
#, fuzzy
msgid "decode the response as JSON;"
msgstr "将响应解码为 JSON 格式；"

#: ../../tutorial/tutorial-7.rst:63 56982d0bf31f47b882c7f3c0fbd6e972
#, fuzzy
msgid "extract the body of the post; and"
msgstr "提取帖子正文；以及"

#: ../../tutorial/tutorial-7.rst:65 2e494ff3c906400eb0a3673c5505d795
#, fuzzy
msgid "include the body of that post as the text of the dialog."
msgstr "将该帖子的正文作为对话框的文本。"

#: ../../tutorial/tutorial-7.rst:67 1a18c6090bb4424a808b3a39b6c9bd48
#, fuzzy
msgid "Lets run our updated app in Briefcase developer mode to check that our change has worked."
msgstr "让我们在公文包开发者模式下运行更新后的应用程序，检查我们的更改是否有效。"

#: ../../tutorial/tutorial-7.rst:72 ../../tutorial/tutorial-7.rst:138 ../../tutorial/tutorial-7.rst:187 ../../tutorial/tutorial-7.rst:409 7bdd2fffeb32409f8bcc7143ecccb2e2 910885354fee4bfca9ffe18022ac1c56 9ce215aaab6f4c2fb3f457e14d6cecae b2dcfff9372146899d2309f5741d1106
msgid "macOS"
msgstr "MacOS"

#: ../../tutorial/tutorial-7.rst:92 ../../tutorial/tutorial-7.rst:151 ../../tutorial/tutorial-7.rst:224 ../../tutorial/tutorial-7.rst:430 42a7ad1beb784da287fb2e34526e9bc1 a3473c3453594db9af1399e08fe4d8c3 df70e9d40c2d436e8fa6ed053d6325cd f42850071bd0417699ecc616bee89009
msgid "Linux"
msgstr "Linux"

#: ../../tutorial/tutorial-7.rst:112 ../../tutorial/tutorial-7.rst:164 ../../tutorial/tutorial-7.rst:277 ../../tutorial/tutorial-7.rst:458 0d1a69cd2f4a414cae311ca89484e190 3729ec0e47464fe38cce2e5cc8456a20 c8ba6792ac64463dbc6d4167d40c0a71 e429f78fe30548c2872e2ec7945b3128
msgid "Windows"
msgstr "Windows"

#: ../../tutorial/tutorial-7.rst:132 51d25b00996b4dcb99190ed7b4dd7dd2
#, fuzzy
msgid "What happened? We've added ``httpx`` to our *code*, but we haven't added it to our development virtual environment. We can fix this by installing ``httpx`` with ``pip``, and then re-running ``briefcase dev``:"
msgstr "发生了什么？我们已经将 ``httpx`` 添加到我们的代码*中，但我们还没有将它添加到我们的开发虚拟环境中。我们可以用 ``pip`` 安装 ``httpx``，然后重新运行 ``briefcase dev``："

#: ../../tutorial/tutorial-7.rst:145 ../../tutorial/tutorial-7.rst:158 ../../tutorial/tutorial-7.rst:171 5df27d3381e5431192736e432e52ded1 5e97330de379435d88d7b62f07dd2129 690bcd952e1747e99c60ab895cb92f54
#, fuzzy
msgid "When you enter a name and press the button, you should see a dialog that looks something like:"
msgstr "输入名称并按下按钮后，您会看到一个类似的对话框："

#: ../../tutorial/tutorial-7.rst babb8ed72b064215813323e7389370c7
#, fuzzy
msgid "Hello World Tutorial 7 dialog, on macOS"
msgstr "Hello World 教程 7 对话框，在 macOS 上运行"

#: ../../tutorial/tutorial-7.rst 5697f4d791744f598ceac06e15f8bd7e
#, fuzzy
msgid "Hello World Tutorial 7 dialog, on Linux"
msgstr "Hello World 教程 7 对话框，在 Linux 上"

#: ../../tutorial/tutorial-7.rst 77f97efd518f412d8cf6b34280931ad2
#, fuzzy
msgid "Hello World Tutorial 7 dialog, on Windows"
msgstr "Hello World 教程 7 对话框，在 Windows 上"

#: ../../tutorial/tutorial-7.rst:177 241cb25384834649aede9e5aec456a6d
#, fuzzy
msgid "We've now got a working app, using a third party library, running in development mode!"
msgstr "现在，我们已经有了一个可正常运行的应用程序，它使用第三方库，以开发模式运行！"

#: ../../tutorial/tutorial-7.rst:180 cf59213a33d54b56967a0705c8196612
#, fuzzy
msgid "Running the updated app"
msgstr "运行更新后的应用程序"

#: ../../tutorial/tutorial-7.rst:182 c26364778503455c82449f4879cf54b4
#, fuzzy
msgid "Let's get this updated application code packaged as a standalone app. Since we've made code changes, we need to follow the same steps as in :doc:`Tutorial 4 <tutorial-4>`:"
msgstr "让我们将更新后的应用程序代码打包为独立应用程序。由于我们对代码进行了修改，因此需要遵循 :doc:`Tutorial 4<tutorial-4>` 中的相同步骤："

#: ../../tutorial/tutorial-7.rst:189 ../../tutorial/tutorial-7.rst:226 ../../tutorial/tutorial-7.rst:279 32cb8170093641049fad2dea51b567f7 f281d7b242ef47d68baa1081be6a931b f8093e859aff406a9441c133613a90b2
#, fuzzy
msgid "Update the code in the packaged app:"
msgstr "更新打包应用程序中的代码："

#: ../../tutorial/tutorial-7.rst:200 ../../tutorial/tutorial-7.rst:237 ../../tutorial/tutorial-7.rst:290 21fdec9ea8384464a3ecceb1ba4f6aa4 3c45139a08f54bf5a8224607a452973d b13970edbd1f4fbcb1f3976d5622cbb1
#, fuzzy
msgid "Rebuild the app:"
msgstr "重建应用程序："

#: ../../tutorial/tutorial-7.rst:209 ../../tutorial/tutorial-7.rst:251 ../../tutorial/tutorial-7.rst:299 310516fec9fe44f1af2943231c50ba92 b948d6423ff544768fa91da2d7f83c4e e2040cd02a284c0090373c3bfd45a940
#, fuzzy
msgid "And finally, run the app:"
msgstr "最后，运行应用程序："

#: ../../tutorial/tutorial-7.rst:218 ../../tutorial/tutorial-7.rst:308 7361548a2dc146eeb3880c1f3f5fa755 d4b9d0993cbd41daae7db8170ff83296
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console, plus a crash dialog:"
msgstr "但是，当程序运行时，你会在控制台中看到一个错误，还有一个崩溃对话框："

#: ../../tutorial/tutorial-7.rst 11a394bdeb6c479e841c7a9116d52132
#, fuzzy
msgid "Hello World Tutorial 7 app crash, on macOS"
msgstr "MacOS 上的 Hello World Tutorial 7 应用程序崩溃"

#: ../../tutorial/tutorial-7.rst:260 ba158fdca2e64649b5349cf77f465d2f
#, fuzzy
msgid "However, when the app runs, you'll see an error in the console:"
msgstr "但是，当应用程序运行时，您会在控制台中看到一个错误："

#: ../../tutorial/tutorial-7.rst 34954f42a5874dcc8116b9fb0bac4504
#, fuzzy
msgid "Hello World Tutorial 7 app crash, on Windows"
msgstr "Hello World 教程 7》应用程序崩溃，在 Windows 系统上"

#: ../../tutorial/tutorial-7.rst:314 d0a43ec40cf14c2d902c6f7521fb07ef
#, fuzzy
msgid "Once again, the app has failed to start because ``httpx`` has been installed - but why? Haven't we already installed ``httpx``?"
msgstr "应用程序再次启动失败，因为已经安装了 ``httpx`` - 但为什么呢？我们不是已经安装了 ``httpx`` 吗？"

#: ../../tutorial/tutorial-7.rst:317 91d48bbb0b5f439caf0a416281530682
#, fuzzy
msgid "We have - but only in the development environment. Your development environment is entirely local to your machine - and is only enabled when you explicitly activate it. Although Briefcase has a development mode, the main reason you'd use Briefcase is to package up your code so you can give it to someone else."
msgstr "我们有，但仅限于安装在开发环境。你的开发环境完全在你的机器本地，只有当你明确激活它时才会启用。虽然公文包有开发模式，但使用公文包的主要原因是打包你的代码，这样你就可以把它交给别人。"

#: ../../tutorial/tutorial-7.rst:322 8aa3be8efcac48748a6957016cc19786
#, fuzzy
msgid "The only way to guarantee that someone else will have a Python environment that contains everything it needs is to build a completely isolated Python environment. This means there's a completely isolated Python install, and a completely isolated set of dependencies. This is what Briefcase is building when you run ``briefcase build`` - an isolated Python environment. This also explains why ``httpx`` isn't installed - it has been installed in your *development* environment, but not in the packaged app."
msgstr "要保证别人的 Python 环境包含它所需要的一切，唯一的办法就是构建一个完全隔离的 Python 环境。这意味着有一个完全独立的 Python 安装，和一套完全独立的依赖关系。这就是当你运行 ``briefcase build`` 时，Briefcase 正在构建的 - 一个隔离的 Python 环境。这也解释了为什么没有安装 ``httpx`` - 它已经安装在你的开发环境中，但没有安装在打包的应用程序中。"

#: ../../tutorial/tutorial-7.rst:330 5c13ed8e04ea41fdb4f70d48d7742f47
#, fuzzy
msgid "So - we need to tell Briefcase that our app has an external dependency."
msgstr "因此，我们需要告诉 Briefcase，我们的应用程序有一个外部依赖关系。"

#: ../../tutorial/tutorial-7.rst:333 fe6c4b6d4a644df0943e51c488ca8cfa
#, fuzzy
msgid "Updating dependencies"
msgstr "更新依赖项"

#: ../../tutorial/tutorial-7.rst:335 1b2579e49522498fb4c01afe3c98d5b3
#, fuzzy
msgid "In the root directory of your app, there is a file named ``pyproject.toml``. This file contains all the app configuration details that you provided when you originally ran ``briefcase new``."
msgstr "在应用程序的根目录中，有一个名为 ``pyproject.toml`` 的文件。该文件包含您最初运行 ``briefcase new`` 时提供的所有应用程序配置详细信息。"

#: ../../tutorial/tutorial-7.rst:339 bd03dc6e3a034288bad78d7b8bd03e98
#, fuzzy
msgid "``pyproject.toml`` is broken up into sections; one of the sections describes the settings for your app::"
msgstr "pyproject.toml \"分为多个部分，其中一部分描述了应用程序的设置：："

#: ../../tutorial/tutorial-7.rst:349 4ea8acaba5ce4e85806f3db4e19fe8a0
#, fuzzy
msgid "The ``requires`` option describes the dependencies of our application. It is a list of strings, specifying libraries (and, optionally, versions) of libraries that you want to be included with your app."
msgstr "requires \"选项描述了应用程序的依赖关系。它是一个字符串列表，其中指定了您希望应用程序包含的库（以及可选的版本）。"

#: ../../tutorial/tutorial-7.rst:353 215b6bf62ec8482691874d27e5c3097a
#, fuzzy
msgid "Modify the ``requires`` setting so that it reads::"
msgstr "修改 ``requires`` 设置为：："

#: ../../tutorial/tutorial-7.rst:359 f63c8a1e56404495a968591b8fa270da
#, fuzzy
msgid "By adding this setting, we're telling Briefcase \"when you build my app, run ``pip install httpx`` into the application bundle\". Anything that would be legal input to ``pip install`` can be used here - so, you could specify:"
msgstr "通过添加此设置，我们告诉 Briefcase \"当你构建我的应用程序时，运行 ``pip install httpx`` 到应用程序捆绑包中\"。任何可以合法输入到 ``pip install`` 的内容都可以在这里使用--因此，你可以指定："

#: ../../tutorial/tutorial-7.rst:363 09ca251dbb694feba999515deed93980
#, fuzzy
msgid "A specific library version (e.g., ``\"httpx==0.19.0\"``);"
msgstr "特定的库版本（例如，``\"httpx===0.19.0\"``）；"

#: ../../tutorial/tutorial-7.rst:364 9aafe81552a7412ba26e094fafb4b174
#, fuzzy
msgid "A range of library versions (e.g., ``\"httpx>=0.19\"``);"
msgstr "一系列库版本（例如，``\"httpx>=0.19\"``）；"

#: ../../tutorial/tutorial-7.rst:365 24b64c60bace453fa04c00832c77d67c
#, fuzzy
msgid "A path to a git repository (e.g., ``\"git+https://github.com/encode/httpx\"``); or"
msgstr "指向 git 仓库的路径（例如，``\"git+https://github.com/encode/httpx\"``）；或"

#: ../../tutorial/tutorial-7.rst:367 9f192659ee0e44a79a5f0bc050f2d089
#, fuzzy
msgid "A local file path (However - be warned: if you give your code to someone else, this path probably won't exist on their machine!)"
msgstr "本地文件路径（不过需要注意的是：如果你把代码交给别人，这个路径很可能不存在于他们的机器上！）。"

#: ../../tutorial/tutorial-7.rst:370 1ef80ec77a4a4174815557e319951667
#, fuzzy
msgid "Further down in ``pyproject.toml``, you'll notice other sections that are operating system dependent, like ``[tool.briefcase.app.helloworld.macOS]`` and ``[tool.briefcase.app.helloworld.windows]``. These sections *also* have a ``requires`` setting. These settings allow you to define additional platform-specific dependencies - so, for example, if you need a platform-specific library to handle some aspect of your app, you can specify that library in the platform-specific ``requires`` section, and that setting will only be used for that platform. You will notice that the ``toga`` libraries are all specified in the platform-specific ``requires`` section - this is because the libraries needed to display a user interface are platform specific."
msgstr "在 ``pyproject.toml`` 中的更下面部分，你会注意到与操作系统相关的其他部分，如 ``[tool.briefcase.app.helloworld.macOS]`` 和 ``[tool.briefcase.app.helloworld.windows]``。这些部分**也有一个 ``requires`` 设置。这些设置允许你定义额外的特定平台依赖关系，例如，如果你需要一个特定平台的库来处理应用程序的某些方面，你可以在特定平台的 ``requires`` 部分中指定该库，而该设置将仅用于该平台。你会注意到，所有的 ``toga`` 库都是在特定平台的 ``requires`` 部分中指定的，这是因为显示用户界面所需的库都是特定平台的。"

#: ../../tutorial/tutorial-7.rst:381 9e7f8d1151764405ad0c0a2a1fcaafa2
#, fuzzy
msgid "In our case, we want ``httpx`` to be installed on all platforms, so we use the app-level ``requires`` setting. The app-level dependencies will always be installed; the platform-specific dependencies are installed *in addition* to the app-level ones."
msgstr "在我们的例子中，我们希望 ``httpx`` 安装在所有平台上，因此使用了应用程序级的 ``requires`` 设置。应用程序级的依赖项始终会被安装；特定平台的依赖项会在应用程序级的依赖项之外*安装。"

#: ../../tutorial/tutorial-7.rst:386 d80d4d5c595a467f987bcdef56be01cf
#, fuzzy
msgid "Some binary packages may not be available"
msgstr "某些二进制软件包可能不可用"

#: ../../tutorial/tutorial-7.rst:388 90920f02725e4cc680f90d536982a186
#, fuzzy
msgid "On desktop platforms (macOS, Windows, Linux), any ``pip``-installable can be added to your requirements. On mobile and web platforms, `your options are slightly limited <https://briefcase.readthedocs.io/en/latest/background/faq.html#can-i-use-third-party-python-packages-in-my-app>`__."
msgstr "在桌面平台（macOS、Windows、Linux）上，任何可安装的 \"pip \"都可以添加到您的需求中。在移动和网络平台上，\"您的选择略显有限 <https://briefcase.readthedocs.io/en/latest/background/faq.html#can-i-use-third-party-python-packages-in-my-app>`__。"

#: ../../tutorial/tutorial-7.rst:392 6b785744b7ce43d7bdcf085259c8c6ee
#, fuzzy
msgid "In short; any *pure Python* package (i.e., packages that do *not* contain a binary module) can be used without difficulty. However, if your dependency contains a binary component, it must be compiled; at this time, most Python packages don't provide compilation support for non-desktop platforms."
msgstr "简而言之，任何*纯 Python* 包（即*不包含二进制模块的包）都可以毫无困难地使用。但是，如果您的依赖包包含二进制组件，则必须对其进行编译；目前，大多数 Python 包都不支持非桌面平台的编译。"

#: ../../tutorial/tutorial-7.rst:397 98f1a73578774af5a572423df4373721
#, fuzzy
msgid "BeeWare can provide binaries for some popular binary modules (including ``numpy``, ``pandas``, and ``cryptography``). It's *usually* possible to compile packages for mobile platforms, but it's not easy to set up -- well outside the scope of an introductory tutorial like this one."
msgstr "BeeWare可以为一些流行的二进制模块（包括 \"numpy\"、\"pandas \"和 \"加密\"）提供二进制文件。为移动平台编译软件包通常是可行的，但设置起来并不容易--这已经超出了本入门教程的范围。"

#: ../../tutorial/tutorial-7.rst:402 b12b94bf4507414fb158be2da02fc662
#, fuzzy
msgid "Now that we've told Briefcase about our additional requirements, we can try packaging our app again. Ensure that you've saved your changes to ``pyproject.toml``, and then update your app again - this time, passing in the ``-r`` flag. This tells Briefcase to update requirements in the packaged app:"
msgstr "既然我们已经告诉了 Briefcase 我们的额外需求，那么我们就可以再次尝试打包应用程序了。确保已将更改保存到 ``pyproject.toml``，然后再次更新应用程序--这一次，传递 ``-r`` 标志。这将告诉 Briefcase 更新打包应用程序中的需求："

#: ../../tutorial/tutorial-7.rst:479 ef300c9d587542dbbba930f3c2aa42d7
#, fuzzy
msgid "Once you've updated, you can run ``briefcase build`` and ``briefcase run`` - and you should see your packaged app, with the new dialog behavior."
msgstr "更新完成后，您可以运行 ``briefcase build`` 和 ``briefcase run`` - 您应该会看到打包后的应用程序，并带有新的对话框行为。"

#: ../../tutorial/tutorial-7.rst:484 b21457ac7f364935af4f372957d506a4
#, fuzzy
msgid "The ``-r`` option for updating requirements is also honored by the ``build`` and ``run`` command, so if you want to update, build, and run in one step, you could use ``briefcase run -u -r``."
msgstr "用于更新需求的 ``-r`` 选项也会被 ``build` 和 ``run` 命令接受，因此如果你想一步完成更新、编译和运行，可以使用 ``briefcase run -u -r``。"

#: ../../tutorial/tutorial-7.rst:490 70d1d14b15d64985b7f6bcc6cc830fad
msgid "Next steps"
msgstr "下一步"

#: ../../tutorial/tutorial-7.rst:492 82852a8edaca43c6b335998302820ed0
#, fuzzy
msgid "We've now got an app that uses a third-party library! However, you may have noticed that when you press the button, the app becomes a little unresponsive. Can we do anything to fix this? Turn to :doc:`Tutorial 8 <tutorial-8>` to find out..."
msgstr "我们现在有了一个使用第三方库的应用程序！不过，您可能已经注意到，当您按下按钮时，应用程序会变得有点反应迟钝。我们能解决这个问题吗？请访问 :doc:`Tutorial 8<tutorial-8>` 了解详情..."
